【goroutine】
並列処理　マルチスレッド
package main
 
import (
    "fmt"
	"time"
	"sync"
)
 
func goroutine(s string, wg *sync.WaitGroup) {
	for i := 0; i < 5; i++{
		time.Sleep(300 * time.Millisecond)
		fmt.Println(s)
	}
	wg.Done()//処理が終わりやした
}

func normal(s string) {
	for i := 0; i < 5; i++{
		time.Sleep(300 * time.Millisecond)
		fmt.Println(s)
	}
}
 
func main(){
	var wg sync.WaitGroup 
	wg.Add(1)//１個の並列処理がありますぽ？wg.Done()と同じ数になるようにする。
	go goroutine("world", &wg) //並列化。
	normal("hello") //sleepしないとgoが実行される前にコードが終了してしまう。
	wg.Wait() //wg.Done()まで待ってください。
}

【channel】
ゴルーチンと関数のデータのやり取り

package main
 
import (
    "fmt"
)

func goroutine(s []int, c chan int){
	sum := 0
	for _, v := range s {
		sum = sum + v
	}
	c <- sum
}

func goroutine2(s []int, c chan int){
	sum := 0
	for _, v := range s {
		sum = sum + v
	}
	c <- sum + 5
}
 
func main(){
	s := []int{1,2,3,4,5}
	c := make(chan int)
	go goroutine(s, c)
	go goroutine2(s, c)
	x := <-c
	fmt.Println(x)
	y := <-c
	fmt.Println(y)
}

【channel2】
package main
 
import (
    "fmt"
)

func main(){
	ch := make(chan int, 2) //キャパが2のチャネルを生成
	ch <- 100
	fmt.Println(len(ch))
	ch <- 200
	fmt.Println(len(ch))
//ここでさらにチャネルに値を入れようとすると、キャパオーバとなりエラーになる
	x := <- ch //ここでチャネルから値を取り出す。(FIFO)
	fmt.Println(x)
	ch <- 300 //一つ取り出したので新しい値を入れることができる。
	fmt.Println(ch)
	close(ch) //チャネルを閉じてからfor文回す

	for c := range ch {
		fmt.Println(c)
	}
}

【channel3】
package main
 
import (
    "fmt"
)

func goroutine(s []int, c chan int){
	sum := 0
	for _, v := range s {
		sum = sum + v
		c <- sum
	}
	close(c)
}

 
func main(){
	s := []int{1,2,3,4,5}
	c := make(chan int)
	go goroutine(s, c)
	for i := range c { //Goが回っている限りfor文は回る。
		fmt.Println(i)
	}
}