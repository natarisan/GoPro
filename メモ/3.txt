【producerとconsumer】
package main
 
import (
    "fmt"
	"sync"
)

func producer(ch chan int, i int){
	ch <- i * 2
}

func consumer(ch chan int, wg *sync.WaitGroup) {
	for i := range ch {
		fmt.Println("process", i * 1000)
		wg.Done()//Add(1)が終わりましたよ
	}
}
 
func main(){
	var wg sync.WaitGroup
	ch := make(chan int)

	for i:= 0; i < 10; i++ {
		wg.Add(1)
		go producer(ch, i)
	}

	go consumer(ch, &wg)
	wg.Wait() //chが全て取り終わるまで待ってやる
	close(ch) //最後にチャネルは必ず閉じる
}

【fan-out fan-in】
ゴルーチン１→ゴルーチン２→ゴルーチン３→main()

package main
 
import (
    "fmt"
)

func producer(ch1 chan int) {
	defer close(ch1)
	for i := 0; i < 10; i++ {
		ch1 <- i
	}
}

func second(ch1 <-chan int, ch2 chan<- int) { //受信、送信
	defer close(ch2) //入れる操作の後に必ず閉じなければならない
	for i := range ch1 {
		ch2 <- i * 1000
	}
}

func third(ch2 chan int, ch3 chan int) {
	defer close(ch3)
	for i := range ch2 {
		ch3 <- i * 1000
	}
}

func main(){
	ch1 := make(chan int)
	ch2 := make(chan int)
	ch3 := make(chan int)
	
	go producer(ch1)
	go second(ch1,ch2)
	go third(ch2, ch3)
	for i := range ch3 {
		fmt.Println(i)
	}
}

【Selectを用いたchannelの受信】
package main
 
import (
    "fmt"
	"time"
)

func goroutine1(ch1 chan string){
	for{
		ch1 <- "packet from msg1!!!..."
		time.Sleep(1 * time.Second)
	}
}

func goroutine2(ch2 chan string) {
	for{
		ch2 <- "packet from msg2!!!..."
		time.Sleep(2 * time.Second)
	}
}

func main(){
	ch1 := make(chan string)
	ch2 := make(chan string)
	go goroutine1(ch1)
	go goroutine2(ch2)

	for{
		select{
		case msg1 := <-ch1:
			fmt.Println(msg1)
		case msg2 := <-ch2:
			fmt.Println(msg2)
		}
	}
}

【default Selection】
package main
 
import (
    "fmt"
	"time"
)

func main() {
	tick := time.Tick(100 * time.Millisecond)
	boom := time.After(500 * time.Millisecond)

	OuterLoop: //for文の前にループ名をかける。
	for{
		select{
		case <- tick:
			fmt.Println("tick.")
		case <- boom:
			fmt.Println("boom!")
			break OuterLoop //break ループ名でそのループを抜ける
		default:
			fmt.Println(".")
			time.Sleep(50 * time.Millisecond)
		}
	}
}

【sync.Mutex】
複数のゴルーチンで同じ値を更新するとき、並列処理のため
同時に値に更新がかかってしまうことがありエラーになる。
そんな時、値を更新する際にロック・アンロックをかけるのが
これである。

package main
 
import (
    "fmt"
	"time"
	"sync"
)

type Counter struct {
	v map[string]int
	mux sync.Mutex
}

func (c *Counter) Inc(key string) {
	c.mux.Lock()
	defer c.mux.Unlock()
	c.v[key]++
}

func (c *Counter) Value(key string) int{
	c.mux.Lock()
	defer c.mux.Unlock()
	return c.v[key]
}

func main() {
	c := Counter{v: make(map[string]int)}

	go func(){
		for i := 0; i < 10; i++{
			c.Inc("aaa")
		}
	}()
	go func(){
		for i := 0; i < 10; i++{
			c.Inc("aaa")
		}
	}()
	time.Sleep(1 * time.Second)
	fmt.Println(c, c.Value("aaa"))
}