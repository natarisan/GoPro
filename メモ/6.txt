【json.Marshal json.Unmarshal】
import(
    "fmt"
    "encoding/json"
)
 
type Person struct {
    Name string           `json:"name"` //jsonをmarshalするときにキー名を指定 omitempty
    Age int               `json:"age,string"`//marshalの時にstringにすることも可能
    NickNames []string    `json:"-"`//ハイフンつけるとその値が消える
}

func (p Person) MarshalJson()([]byte, error){ 
    //marshal/unmarshalのオーバーライド。
    //メソッド名はこれでなければならない。
    v, err := json.Marshal(&struct{
        Name string
    }{
        Name: "Mr." + p.Name,
    })
    return v, err
}

func (p *Person) UnmarshalJSON(b []byte) error {
    type Person2 struct{
        Name string
    }
    var p2 Person2
    err := json.Unmarshal(b, &p2)
    if err != nil {
        fmt.Println(err)
    }
    p.Name = p2.Name
    return err
}
 
func main(){
    b := []byte(`{"name":"mike","age":20,"nicknames":["a","b","c"]}`)
    //jsonとPersonの構造体の名前が紐づいている必要がある（大文字と小文字の区別はどうでもよい）
    var p Person
    if err := json.Unmarshal(b, &p); err != nil{//JSON→struct (json, 構造体)
        fmt.Println(err)
    }
    fmt.Println(p.Name, p.Age, p.NickNames)

    v, _ := json.Marshal(p)
    fmt.Println(string(v))
}

【hmac】
apiでサーバにアクセスする際のauthenticationでヘッダーに含める
①ハッシュか
②それに送りたいデータを入れてnilを加える
REST関係の認証でよく使われる。

import(
    "crypto/hmac"
    "crypto/sha256"
    "encoding/hex"
    "fmt"
)

var DB = map[string]string{
    "User1Key": "User1Secret",
    "User2Key": "User2Secret",
    "User3Key": "User3Secret",
}

func Server(apiKey, sign string, data []byte){
    apiSecret := DB[apiKey]
    mac := hmac.New(sha256.New, []byte(apiSecret))
    mac.Write(data)
    expectedHMAC := hex.EncodeToString(mac.Sum(nil))
    fmt.Println(sign == expectedHMAC)
}

func main() {
    const apiKey = "User1Key"
    const apiSecret = "User1Secret"

    data := []byte("data")
    mac := hmac.New(sha256.New, []byte(apiSecret))
    mac.Write(data)
    sign := hex.EncodeToString(mac.Sum(nil))

    fmt.Println(sign)
    Server(apiKey, sign, data)
}

【semaphore】
ゴルーチンが走っている数を限定することができる。
コンテクストを使う

import(
    "context"
    "fmt"
    "time"
    "golang.org/x/sync/semaphore"
)

var s *semaphore.Weighted = semaphore.NewWeighted(2) //セマフォの宣言 数はチャネルの数

func longProcess(ctx context.Context) {

    isAcquire := s.TryAcquire(1) //ゴルーチンを取得できたらtrueを返す
    if !isAcquire { //他はブロックされて処理が終了する
        fmt.Println("could not get lock")
        return
    }
    //if err := s.Acquire(ctx, 1); err != nil {//コンテクストを用いて一つ受け付ける
      //  fmt.Println(err)　他は待ち状態になる
        //return
    //}
    defer s.Release(1) //処理が終わったらリリースする
    fmt.Println("Wait...")
    time.Sleep(1 * time.Second)
    fmt.Println("Done")
}

func main() {
    ctx := context.TODO()
    go longProcess(ctx)
    go longProcess(ctx)
    go longProcess(ctx)
    time.Sleep(5 * time.Second)
}

【ini】
iniファイルを読む
