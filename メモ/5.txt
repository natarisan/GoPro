【標準パッケージ】
①time
時間を司るパッケージなのだ
func main(){
    t := time.Now()
    fmt.Println(t)
    fmt.Println(t.Format(time.RFC3339)) //timeの表示のさせ方（フォーマット)を決定。
    fmt.Println(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second())
}

②regexp
正規表現を司るパッケージ

import ("fmt"
        "regexp"
)
 
func main(){
    match, _ := regexp.MatchString("a([a-z]+)e", "apple") 
    //aで始まってeで終わり、その間にa-zのアルファベットが1個以上あるもの
    fmt.Println(match)
    r := regexp.MustCompile("a([a-z]+)e")//この正規表現と比べてよという宣言
    ms := r.MatchString("apple")
    fmt.Println(ms)   
    
    r2 := regexp.MustCompile("^/(edit|save|view)/([a-zA-Z0-9]+)$")
    fs := r2.FindString("/view/test")
    fmt.Println(fs)

    fss := r2.FindStringSubmatch("/view/test")
    fmt.Println(fss) //fssにはスライスが入っている
    fmt.Println(fss[1])
}

③Sort
import ("fmt"
        "sort"
    )
 
func main(){
    i := []int{1,2,3,4,5}
    s := []string{"い","あ","お"}
    p := []struct{
        Name string
        Age int
    }{
        {"eren", 25},
        {"izabera",29},
        {"ken", 22},
        {"robert", 18},
    }
    fmt.Println(i,s,p)
    sort.Ints(i)//昇順に並べる
    sort.Strings(s)//アルファベット順/アイウエオ順で並べる
    sort.Slice(p, func(i, j int) bool { return p[i].Name < p[j].Name })
    sort.Slice(p, func(i, j int) bool { return p[i].Age < p[j].Age })
    //iとjのforループで少ないものを前に持ってきてくれる
    fmt.Println(i, s, p)
}

④iota
import "fmt"

const(
    c1 = iota //連番0から
    c2 //1  これ以降iotaを書かなくて良い
    c3 //2
)
const(
    _ = iota
    KB int = 1 << (10 * iota)
    MB 
    GB
)
 
func main(){
    fmt.Println(c1, c2, c3)
    fmt.Println(KB, MB, GB)
}

⑤context
ゴルーチンがなかなか終わらない処理の場合、途中でキャンセルしたーいなんてことがあるかも？
import ("fmt"
        "time"
        "context"
)

func longProcess(ctx context.Context, ch chan<- string) {//こちらはコンテクストを渡すだけで良い。
    fmt.Println("run")
    time.Sleep(2 * time.Second)
    fmt.Println("finish")
    ch <- "result"
}
 
func main(){
    ch := make(chan string)
    ctx := context.Background()//コンテクストを作成
    ctx, cancel := context.WithTimeout(ctx, 1 * time.Second)//何もしないcontextを走らせたい場合、context.TODO()とする
    defer cancel()//キャンセルを呼ぶことで、コンテクストを渡したゴルーチンが終わる
    go longProcess(ctx, ch)

    for{
        select{
        case <- ctx.Done()://コンテクストの条件が終わったら呼ばれる
            fmt.Println(ctx.Err())
            return
        case <- ch:
            fmt.Println("success")
            return
        }
    }
}

⑥ioutil
ファイル系
import ("fmt"
        "io/ioutil"
        "log"
)
 
func main(){
    content, err := ioutil.ReadFile("main.go")//ファイル読み込み
    if err != nil{
        log.Fatalln(err)
    }
    fmt.Println(string(content))
    if err := ioutil.WriteFile("io.go", content, 0666); err != nil {
        //ファイル書きだし(出力ファイル名、バイトのコンテンツ、パーミッション)
        log.Fatalln(err)
    }
//r := bytes.NewBuffer([]byte("abc"))バイト型でnewbufferしてabcを入れる
//content,_ := ioutil.ReadAll(r)//ファイル以外はreadall
//fmt.Println(string(content))
}